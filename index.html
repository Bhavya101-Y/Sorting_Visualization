<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Animated Sorting Visualizer — All Algorithms</title>
<style>
  :root{
    --bg:#071226; --panel:#071a2a; --muted:#f1f5f8;
    --blue:#60a5fa; --yellow:#f59e0b; --red:#ef4444; --green:#10b981;
    --card:#0b1220;
  }
  *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
  body{margin:0;min-height:100vh;background:linear-gradient(180deg,#031124,#071226);color:#e2e8ec}
  header{padding:16px 20px;display:flex;align-items:center;gap:12px;background:linear-gradient(90deg,#07203a,#082233)}
  header h1{margin:0;font-size:18px}
  .wrap{display:grid;grid-template-columns:340px 1fr;gap:18px;padding:18px;align-items:start}
  .panel{background:rgba(255,255,255,0.03);padding:14px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:8px}
  select,input[type=range],button{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .controls{display:flex;gap:8px}
  .controls button{flex:1}
  .small{font-size:12px;color:var(--muted)}
  .footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
  /* visualization area */
  .vis-wrap{display:flex;flex-direction:column;gap:10px}
  .bars{height:60vh;background:linear-gradient(180deg,#071428,#02131b);border-radius:12px;padding:10px;display:flex;align-items:end;gap:2px;overflow:hidden}
  .bar{flex:1 0 auto;background:var(--blue);border-radius:4px 4px 2px 2px;transition: height 300ms ease, background-color 200ms ease, transform 200ms ease;}
  .bar-label{font-size:11px;color:var(--muted);text-align:center;margin-top:6px}
  .info-row{display:flex;justify-content:space-between;gap:8px;font-size:13px;color:var(--muted);align-items:center}
  .btn-row{display:flex;gap:8px}
  /* small responsive */
  @media(max-width:900px){.wrap{grid-template-columns:1fr;padding:10px}.bars{height:50vh}}
</style>
</head>
<body>
  <header>
    <h1>Sorting Visualizer — Animated (All Algorithms)</h1>
    <div style="color:var(--muted);font-size:13px;margin-left:6px">Bubble • Selection • Insertion • Merge • Quick • Heap • Counting • Radix • Bucket</div>
  </header>
    <div class="wrap">
    <div class="panel">
      <div style="margin-bottom:12px">
        <label>Algorithm</label>
        <select id="algo">
          <option value="bubble">Bubble Sort</option>
          <option value="selection">Selection Sort</option>
          <option value="insertion">Insertion Sort</option>
          <option value="merge">Merge Sort</option>
          <option value="quick">Quick Sort</option>
          <option value="heap">Heap Sort</option>
          <option value="counting">Counting Sort</option>
          <option value="radix">Radix Sort (LSD)</option>
          <option value="bucket">Bucket Sort</option>
        </select>
      </div>

      <div style="margin-bottom:12px">
        <label>Array size <span id="sizeLabel" class="small">50</span></label>
        <input id="size" type="range" min="5" max="160" value="50">
      </div>

      <div style="margin-bottom:12px">
        <label>Speed (ms per step) <span id="speedLabel" class="small">60</span></label>
        <input id="speed" type="range" min="10" max="600" value="60">
      </div>

      <div style="display:flex;gap:8px;margin-bottom:12px">
        <button id="newArr">Generate</button>
        <button id="shuffle">Shuffle</button>
      </div>

      <div class="btn-row" style="margin-bottom:12px">
        <button id="start">Start</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
      </div>

      <div style="margin-top:10px;font-size:13px;color:var(--muted)">
        <div>Tips: Choose algorithm → Generate → Start. Use Speed slider for animation pace.</div>
      </div>
    </div>

    <div class="panel vis-wrap">
      <div class="bars" id="bars" aria-hidden="false"></div>
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Comparisons: <span id="comp">0</span></div>
        <div class="small">Swaps/Writes: <span id="swaps">0</span></div>
        <div class="small">Status: <span id="status">idle</span></div>
      </div>
    </div>
  </div>


<script>

const barsEl = document.getElementById('bars');
const algoSel = document.getElementById('algo');
const sizeInput = document.getElementById('size');
const speedInput = document.getElementById('speed');
const sizeLabel = document.getElementById('sizeLabel');
const speedLabel = document.getElementById('speedLabel');
const newBtn = document.getElementById('newArr');
const shuffleBtn = document.getElementById('shuffle');
const startBtn = document.getElementById('start');
const pauseBtn = document.getElementById('pause');
const resetBtn = document.getElementById('reset');
const compEl = document.getElementById('comp');
const swapsEl = document.getElementById('swaps');
const statusEl = document.getElementById('status');

let arr = [];
let maxVal = 100;
let paused = false;
let running = false;
let compCount = 0, swapCount = 0;
let speed = +speedInput.value;


function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

function setStatus(s){ statusEl.textContent = s; }

function resetStats(){ compCount=0; swapCount=0; compEl.textContent=0; swapsEl.textContent=0; }

function updateStats(){ compEl.textContent = compCount; swapsEl.textContent = swapCount; }

/* --------------------------
   Build and render bars (divs) so CSS transitions animate height/color
   -------------------------- */
function makeBarsFromArray(a){
  barsEl.innerHTML = ''; // remove old
  const n = a.length;
  maxVal = Math.max(...a, 1);
  for(let i=0;i<n;i++){
    const b = document.createElement('div');
    b.className = 'bar';
    b.dataset.index = i;
    b.style.height = `${(a[i]/maxVal)*100}%`;
    b.style.backgroundColor = 'var(--blue)';
    barsEl.appendChild(b);
  }
}

function updateBarHeight(i, value){
  const b = barsEl.children[i];
  if(!b) return;
  maxVal = Math.max(maxVal, value);
  b.style.height = `${(value/maxVal)*100}%`;
}
function colorBar(i, colorName){
  const b = barsEl.children[i];
  if(!b) return;
  if(colorName==='compare') b.style.backgroundColor = 'var(--yellow)';
  else if(colorName==='swap') b.style.backgroundColor = 'var(--red)';
  else if(colorName==='sorted') b.style.backgroundColor = 'var(--green)';
  else b.style.backgroundColor = 'var(--blue)';
}

/* Reset all bars to default color */
function resetBarColors(){
  for(let b of barsEl.children) b.style.backgroundColor = 'var(--blue)';
}

/* --------------------------
   Generate / Shuffle
   -------------------------- */
function generateArray(n){
  arr = Array.from({length:n}, ()=> Math.floor(Math.random()*200)+5);
  makeBarsFromArray(arr);
  resetStats();
  setStatus('idle');
  running=false; paused=false;
}
function shuffleArray(){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  makeBarsFromArray(arr);
  resetStats();
  setStatus('idle');
  running=false; paused=false;
}



async function opCompare(i,j){
  compCount++; updateStats();
  colorBar(i,'compare'); colorBar(j,'compare');
  await sleep(speed);
  if(paused) await waitWhilePaused();
  resetBarColors();
}

async function opSwap(i,j){
  swapCount++; updateStats();
  colorBar(i,'swap'); colorBar(j,'swap');
  // visually swap heights
  const hi = (arr[i]/maxVal)*100;
  const hj = (arr[j]/maxVal)*100;
  // update underlying array first
  [arr[i], arr[j]] = [arr[j], arr[i]];
  updateBarHeight(i, arr[i]);
  updateBarHeight(j, arr[j]);
  await sleep(speed);
  if(paused) await waitWhilePaused();
  resetBarColors();
}

async function opWrite(i, val){
  swapCount++; updateStats(); // count writes as swaps/writes
  colorBar(i,'swap');
  arr[i] = val;
  updateBarHeight(i, val);
  await sleep(speed);
  if(paused) await waitWhilePaused();
  resetBarColors();
}

function waitWhilePaused(){
  return new Promise(resolve=>{
    const check = () => {
      if(!paused) return resolve();
      setTimeout(check, 100);
    };
    check();
  });
}



async function bubbleSort(){
  const n = arr.length;
  for(let i=0;i<n-1;i++){
    for(let j=0;j<n-1-i;j++){
      if(paused) await waitWhilePaused();
      await opCompare(j,j+1);
      if(arr[j] > arr[j+1]) await opSwap(j,j+1);
    }
    colorBar(n-1-i,'sorted');
  }
  colorAllSorted();
}

async function selectionSort(){
  const n = arr.length;
  for(let i=0;i<n-1;i++){
    let min = i;
    for(let j=i+1;j<n;j++){
      if(paused) await waitWhilePaused();
      await opCompare(min,j);
      if(arr[j] < arr[min]) min = j;
    }
    if(min !== i) await opSwap(i,min);
    colorBar(i,'sorted');
  }
  colorAllSorted();
}

async function insertionSort(){
  const n = arr.length;
  for(let i=1;i<n;i++){
    let key = arr[i];
    let j = i-1;
    while(j>=0){
      if(paused) await waitWhilePaused();
      await opCompare(j, i);
      if(arr[j] > key){
        await opWrite(j+1, arr[j]);
        j--;
      } else break;
    }
    await opWrite(j+1, key);
  }
  colorAllSorted();
}

async function mergeSortAnim(l=0, r=arr.length-1){
  if(l>=r) return;
  const m = Math.floor((l+r)/2);
  await mergeSortAnim(l,m);
  await mergeSortAnim(m+1,r);
  // merge step
  let left = arr.slice(l, m+1);
  let right = arr.slice(m+1, r+1);
  let i=0,j=0,k=l;
  while(i<left.length && j<right.length){
    if(paused) await waitWhilePaused();
    await opCompare(l+i, m+1+j);
    if(left[i] <= right[j]){
      await opWrite(k, left[i]); i++;
    } else {
      await opWrite(k, right[j]); j++;
    }
    k++;
  }
  while(i<left.length){
    if(paused) await waitWhilePaused();
    await opWrite(k, left[i]); i++; k++;
  }
  while(j<right.length){
    if(paused) await waitWhilePaused();
    await opWrite(k, right[j]); j++; k++;
  }
}

async function quickSortAnim(l=0, r=arr.length-1){
  if(l>=r) {
    if(l===r) colorBar(l,'sorted');
    return;
  }
  let pivot = arr[r];
  let i = l;
  for(let j=l;j<r;j++){
    if(paused) await waitWhilePaused();
    await opCompare(j,r);
    if(arr[j] < pivot){
      await opSwap(i,j);
      i++;
    }
  }
  await opSwap(i,r);
  // mark pivot position as sorted-ish (we'll recolor later)
  colorBar(i,'sorted');
  await quickSortAnim(l, i-1);
  await quickSortAnim(i+1, r);
}

async function heapSortAnim(){
  const n = arr.length;
  async function heapify(n, i){
    let largest = i;
    const l = 2*i + 1, r = 2*i + 2;
    if(l < n){ await opCompare(l, largest); if(arr[l] > arr[largest]) largest = l; }
    if(r < n){ await opCompare(r, largest); if(arr[r] > arr[largest]) largest = r; }
    if(largest !== i){
      await opSwap(i, largest);
      await heapify(n, largest);
    }
  }
  for(let i=Math.floor(n/2)-1;i>=0;i--) await heapify(n, i);
  for(let i=n-1;i>0;i--){
    await opSwap(0, i);
    colorBar(i,'sorted');
    await heapify(i, 0);
  }
  colorAllSorted();
}

async function countingSortAnim(){
  // Counting sort works for non-negative integers; find range
  const n = arr.length;
  if(n === 0) return;
  const maxV = Math.max(...arr);
  const minV = Math.min(...arr);
  if(minV < 0){
    // shift to positive by offset
    var offset = -minV;
  } else offset = 0;
  const range = maxV + offset;
  const count = new Array(range+1).fill(0);
  // count occurrences
  for(let i=0;i<n;i++){
    if(paused) await waitWhilePaused();
    count[arr[i]+offset]++;
    colorBar(i,'compare');
    await sleep(speed/3);
    resetBarColors();
  }
  // prefix sum
  for(let i=1;i<count.length;i++) count[i]+=count[i-1];
  // output array
  const output = new Array(n);
  for(let i=n-1;i>=0;i--){
    if(paused) await waitWhilePaused();
    const val = arr[i]+offset;
    const pos = --count[val];
    output[pos] = arr[i];
    // write into visual array (we'll overwrite arr progressively)
    await opWrite(pos, output[pos]);
  }
  // copy back is already visualized via writes
  colorAllSorted();
}

async function radixSortAnim(){
  // LSD radix sort for non-negative integers
  const n = arr.length;
  if(n===0) return;
  const maxV = Math.max(...arr);
  let exp = 1;
  while(Math.floor(maxV/exp) > 0){
    // counting sort by digit
    const output = new Array(n).fill(0);
    const count = new Array(10).fill(0);
    for(let i=0;i<n;i++){
      if(paused) await waitWhilePaused();
      const d = Math.floor((arr[i]/exp) % 10);
      count[d]++;
      colorBar(i,'compare'); await sleep(speed/4); resetBarColors();
    }
    for(let i=1;i<10;i++) count[i]+=count[i-1];
    for(let i=n-1;i>=0;i--){
      if(paused) await waitWhilePaused();
      const d = Math.floor((arr[i]/exp) % 10);
      const pos = --count[d];
      output[pos] = arr[i];
    }
    // write back
    for(let i=0;i<n;i++){
      await opWrite(i, output[i]);
    }
    exp *= 10;
  }
  colorAllSorted();
}

async function bucketSortAnim(){
  // Bucket sort for numbers in known range (we'll normalize using max)
  const n = arr.length;
  if(n===0) return;
  const bucketCount = Math.max(1, Math.floor(Math.sqrt(n)));
  const buckets = Array.from({length:bucketCount}, ()=>[]);
  const maxV = Math.max(...arr);
  // distribute
  for(let i=0;i<n;i++){
    if(paused) await waitWhilePaused();
    const idx = Math.floor((arr[i] / (maxV+1)) * bucketCount);
    buckets[Math.min(idx,bucketCount-1)].push(arr[i]);
    colorBar(i,'compare'); await sleep(speed/4); resetBarColors();
  }
  // sort each bucket (use built-in sort for simplicity) and write back
  let idx = 0;
  for(let b=0;b<bucketCount;b++){
    buckets[b].sort((a,b)=>a-b);
    for(let v of buckets[b]){
      await opWrite(idx, v);
      idx++;
    }
  }
  colorAllSorted();
}

/* --------------------------
   Helpers to color sorted final or single index
   -------------------------- */
function colorAllSorted(){
  for(let i=0;i<barsEl.children.length;i++) colorBar(i,'sorted');
  setStatus('done');
}

function colorRangeSorted(l, r){
  for(let i=l;i<=r;i++) colorBar(i,'sorted');
}

/* --------------------------
   Runner: decides which algorithm to run
   -------------------------- */
async function runSelected(){
  if(running) return;
  running = true;
  paused = false;
  resetStats();
  setStatus('running');
  const choice = algoSel.value;
  try{
    if(choice === 'bubble') await bubbleSort();
    else if(choice === 'selection') await selectionSort();
    else if(choice === 'insertion') await insertionSort();
    else if(choice === 'merge') await mergeSortAnim(0, arr.length-1);
    else if(choice === 'quick') await quickSortAnim(0, arr.length-1);
    else if(choice === 'heap') await heapSortAnim();
    else if(choice === 'counting') await countingSortAnim();
    else if(choice === 'radix') await radixSortAnim();
    else if(choice === 'bucket') await bucketSortAnim();
    if(!paused) colorAllSorted();
  } catch(e){
    console.error(e);
  }
  running = false;
  if(!paused) setStatus('done');
}

/* --------------------------
   UI wiring
   -------------------------- */
sizeInput.addEventListener('input', ()=>{
  sizeLabel.textContent = sizeInput.value;
  generateArray(+sizeInput.value);
});
speedInput.addEventListener('input', ()=>{
  speedLabel.textContent = speedInput.value;
  speed = +speedInput.value;
  // adjust CSS transition according to speed (faster speed -> shorter transition)
  const ms = Math.max(30, Math.min(600, speed));
  // Bar height transition is already 300ms in css; alter slightly:
  for(let b of barsEl.children) b.style.transition = `height ${Math.max(30, Math.round(ms/1.8))}ms ease, background-color 120ms`;
});
newBtn.addEventListener('click', ()=> generateArray(+sizeInput.value));
shuffleBtn.addEventListener('click', ()=> shuffleArray());
startBtn.addEventListener('click', ()=> { if(!running) runSelected(); else { paused=false; setStatus('running'); }});
pauseBtn.addEventListener('click', ()=> { paused = !paused; setStatus(paused ? 'paused' : 'running'); });
resetBtn.addEventListener('click', ()=>{
  paused = false; running = false; resetStats(); setStatus('idle'); makeBarsFromArray(arr);
});

/* --------------------------
   Initialize
   -------------------------- */
sizeLabel.textContent = sizeInput.value;
speedLabel.textContent = speedInput.value;
speed = +speedInput.value;
generateArray(+sizeInput.value);




</script>
</body>
</html>
